<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PONG!</title>
    <style>
        #myCanvas {
            border: 1px, #888 solid;
        }
        body {
            background-color: #b1f2ff;
        }
        h1 {
            size: 40px;
        }
        p {
            size: 12px;
        }
    </style>
</head>

<body onload="start()">
    <div>
        <p style="text-align: left;">Player 1</p>
        <p id="score1" style="text-align: left;"> ------ </p>
        <p id="lives1" style="text-align: left;"> ------ </p>
        <p style="text-align: right;">Player 2</p>
        <p id="score2" style="text-align: right;"> ------ </p>
        <p id="lives2" style="text-align: right;"> ------ </p>
    </div>

    <div style="text-align: center;">
        <h1>PONG!</h1>
        <canvas id="myCanvas" width="800" height="800"></canvas>
        <p id="msg"></p>
    </div>
</body>

</html>
<script>

    const canvas = document.getElementById("myCanvas")

    var player1 = {
        lives: 10,
        score: 0, 
    }

    var player2 = {
        lives: 10,
        score: 0, 
    }

    var obj = { // our object with different properties
        x: 0,
        y: 0,
        w: 10,
        h: 10,
        deltaX: 3,
        deltaY: 2
    }

    var env = {
        rows: 20,
        columns: 20,
        c: null, // our canvas
        ctx: null, // 2d-context 
    }

    var paddle = {
        x: 40,
        y: 100,
        w: canvas.width * 0.02,
        h: canvas.height * 0.2
    }

    var paddle2 = {
        x: 745,
        y: 550,
        w: canvas.width * 0.02,
        h: canvas.height * 0.2
    }

    function gameLogic() {
        // movement
        obj.x += obj.deltaX;
        obj.y += obj.deltaY;

        // y-bounce
        if (obj.y > env.c.height - 10 || obj.y < 0)
            obj.deltaY = -obj.deltaY;

        // collision
        let coll = intersect(obj, paddle) 
        let coll2 = intersect(obj, paddle2)
        if (coll || coll2) {
            obj.deltaX = -obj.deltaX
        }

        // Score PLAYER 1
        if (obj.x > env.c.width + 20) {
            player1.score += 1;
            player2.lives -= 1;
            document.getElementById("score1").innerHTML = "Score = " + player1.score;
            document.getElementById("lives2").innerHTML = "Lives = " + player2.lives;
            obj.x = 250;
            obj.y = 250;
        }

        // Score PLAYER 2
        if (obj.x < -20) {
            player2.score += 1;
            player1.lives -= 1;
            document.getElementById("score2").innerHTML = "Score = " + player2.score;
            document.getElementById("lives1").innerHTML = "Lives = " + player1.lives;
            obj.x = 250;
            obj.y = 250;
        }

        // Gameover
        if (player1.score == 10) {
            gameover();
            document.getElementById("msg").innerHTML = "Game Over. Player 1 Wins.";
        }
        else if (player2.score == 10) {
            gameover();
            document.getElementById("msg").innerHTML = "Game Over. Player 2 Wins.";
        }
    }

    function cyclic() {
        gameLogic();
        draw();     // draw everything, no matter how tiny the change to the picture   
    }

    function start() {
        env.c = document.getElementById("myCanvas"); // get canvas element and store reference globally
        env.c.setAttribute('tabindex', '0');
        env.c.focus(); // divert keyboard to the canvas
        // canvas.addEventListener('mousedown', f_mousedown, false);
        env.c.addEventListener('keypress', f_keypress1, false);
        env.c.addEventListener('keypress', f_keypress2, false);
        env.ctx = env.c.getContext("2d"); // same thing for the toolbox (context = toolbox)
        setInterval(cyclic, 15); // do game Logic periodically
    }

    function f_keypress1(e) {
        console.log("key=" + e.code);
        if (e.code == "KeyW")
            paddle.y -= 20;
        if (e.code == "KeyS")
            paddle.y += 20;
    }

    function f_keypress2(e) {
        console.log("key=" + e.code);
        if (e.code == "KeyO")
            paddle2.y -= 20;
        if (e.code == "KeyL")
            paddle2.y += 20;
    }

    function gameover() {
        obj.deltaX = 0;
        obj.deltaY = 0;
        obj.x = 400 - (obj.w / 2);
        obj.y = 400 - (obj.h / 2);
    }

    function draw() {

        // var c = document.getElementById("myCanvas");
        env.c.width = env.c.width; // delete everything
        drawGrid();
        drawPaddle();
        drawPaddle2();
        drawObj(obj.x, obj.y);
    }

    function drawPaddle() {
        env.ctx.fillStyle = "darkred";
        env.ctx.fillRect(paddle.x, paddle.y, paddle.w, paddle.h);
    }

    function drawPaddle2() {
        env.ctx.fillStyle = "darkgreen";
        env.ctx.fillRect(paddle2.x, paddle2.y, paddle2.w, paddle2.h);
    }
    function drawGrid() {
        env.ctx.fillStyle = "#ccc";
        env.ctx.lineWidth = 0.1;

        for (var i = 0; i <= env.rows; i++) {
            env.ctx.moveTo(0, i * (env.c.height / env.rows));
            env.ctx.lineTo(env.c.width, i * (env.c.height / env.rows));
        }
        for (var i = 0; i <= env.columns; i++) {
            env.ctx.moveTo(i * (env.c.width / env.columns), 0);
            env.ctx.lineTo(i * (env.c.width / env.columns), env.c.height);
        }
        env.ctx.stroke();
    }

    function drawObj(x, y) {
        env.ctx.fillStyle = "red";
        env.ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
    }

    function intersect(R1, R2) {
        if (R1.x + R1.w < R2.x)
            return false; // R1 entirely left of R2
        if (R1.y + R1.h < R2.y)
            return false; // R1 above R2
        if (R2.x + R2.w < R1.x)
            return false; // R2 entirely left of R1
        if (R2.y + R2.h < R1.y)
            return false; // R2 above R1
        return true;
    }

</script>